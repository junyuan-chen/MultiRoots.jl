<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · NonlinearSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://junyuan-chen.github.io/NonlinearSystems.jl/stable/man/getting-started/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NonlinearSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Getting Started</a></li><li><a class="tocitem" href="../solver-options/">Solver Options</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/junyuan-chen/NonlinearSystems.jl/blob/main/docs/src/man/getting-started.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h1><p>Suppose the system of nonlinear equations of interest can be described as follows:</p><pre><code class="language-julia hljs">using NonlinearSystems

# Residual function
function f!(F, x)
    F[1] = (x[1] + 3) * (x[2]^3 - 7) + 18
    F[2] = sin(x[2] * exp(x[1]) - 1)
    return F
end

# Jacobian function (optional)
function j!(J, x)
    J[1,1] = x[2]^3 - 7
    J[1,2] = 3 * x[2]^2 * (x[1] + 3)
    u = exp(x[1]) * cos(x[2] * exp(x[1]) - 1)
    J[2,1] = x[2] * u
    J[2,2] = u
    return J
end

# Initial value
x0 = [0.1, 1.2]</code></pre><p>To solve the above equations as a root-finding problem, we specify the <code>Hybrid</code> algorithm by passing either <code>Hybrid</code> or <code>Hybrid{RootFinding}</code> as the first argument:</p><pre><code class="language-julia hljs"># Evaluate Jacobians via finite differencing methods from FiniteDiff.jl
solve(Hybrid, f!, x0)
# Use user-specified Jacobian function and separate out the initialization step
s = init(Hybrid, f!, j!, x0)
solve!(s)</code></pre><p>The last line from above calls a non-allocating method <code>solve!</code> that mutates the pre-allocated problem <code>s</code> in-place. On Julia REPL, the essential information is summarized as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s</code><code class="nohighlight hljs ansi" style="display:block;">2×2 NonlinearSystem{RootFinding, Vector{Float64}, Matrix{Float64}, HybridSolver{Float64, DenseLUSolver{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}}, Vector{Float64}}, Nothing, Nothing}:
  Problem type:                 Root finding
  Algorithm:                    Hybrid
  Candidate (x):                [-6.06188e-10, 1.0]
  ‖f(x)‖₂:                      6.971672272635292e-9
  ‖Ddx‖₂:                       1.1197356805172518e-5
  Solver exit state:            ftol_reached
  Iterations:                   7
  Residual calls (f):           7
  Jacobian calls (df/dx):       1</code></pre><p>The solution can be retrieved by accessing the corresponding field:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s.x</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 -6.061879300097132e-10
  0.9999999988463306</code></pre><p>In general, a nonlinear system of equations may have multiple solutions or no solution. If only solutions that fall in certain regions are of interest, we may impose lower and upper bounds that force the solver to only seek solution candidates within the bounded areas:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solve(Hybrid, f!, ones(2), lower=fill(0.5,2), upper=fill(2.0,2))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 NonlinearSystem{RootFinding, Vector{Float64}, Matrix{Float64}, HybridSolver{Float64, DenseLUSolver{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}}, Vector{Float64}}, Vector{Float64}, Vector{Float64}}:
  Problem type:                 Root finding
  Algorithm:                    Hybrid
  Candidate (x):                [1.10117, 1.37701]
  ‖f(x)‖₂:                      1.66896278574161e-9
  ‖Ddx‖₂:                       1.0356454220559748e-6
  Solver exit state:            ftol_reached
  Iterations:                   8
  Residual calls (f):           11
  Jacobian calls (df/dx):       3</code></pre><p>Notice that we have found a different solution in the above example.</p><p>In practice, we often do not expect the existence of solutions that solve the equations exactly as identities. Instead, we may solve a least-squares problem that minimizes the Euclidean norm of residuals. To do so, simply specify the algorithm type as <code>Hybrid{LeastSquares}</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = solve(Hybrid{LeastSquares}, f!, x0)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 NonlinearSystem{LeastSquares, Vector{Float64}, Matrix{Float64}, HybridSolver{Float64, DenseCholeskySolver{Float64, Int8, Matrix{Float64}, Vector{Float64}, Nothing}, Vector{Float64}}, Nothing, Nothing}:
  Problem type:                 Least squares
  Algorithm:                    Hybrid
  Candidate (x):                [-6.06188e-10, 1.0]
  ‖f(x)‖₂:                      6.971668834975478e-9
  ‖∇f(x)‖₂:                     NaN
  ‖Ddx‖₂:                       1.119735680119611e-5
  Solver exit state:            ftol_reached
  Iterations:                   7
  Residual calls (f):           7
  Jacobian calls (df/dx):       1</code></pre><p>Notice that the gradient norm is <code>NaN</code>. For this specific problem, convergence is attained before the gradient is ever evaluated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A root-finding algorithm requires that the number of variables matches the number of equations. That is, the associated Jacobian matrix must be a square matrix. In contrast, a least-squares algorithm does not impose this restriction.</p></div></div><p>To inspect the solver iteration, summary information can be printed for each evaluation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = solve(Hybrid{LeastSquares}, f!, x0, showtrace=1);</code><code class="nohighlight hljs ansi" style="display:block;">  iter    1  =&gt;  ‖f(x)‖₂ =  1.687505e+00  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =           NaN  δ =  1.612854e+01  ρ =           NaN
  iter    2  =&gt;  ‖f(x)‖₂ =  3.755760e-01  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =  2.350344e+00  δ =  2.350344e+00  ρ =  7.774372e-01
  iter    3  =&gt;  ‖f(x)‖₂ =  5.511315e-02  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =  3.312116e-01  δ =  4.700688e+00  ρ =  8.532570e-01
  iter    4  =&gt;  ‖f(x)‖₂ =  2.152558e-03  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =  3.953811e-02  δ =  4.700688e+00  ρ =  9.609429e-01
  iter    5  =&gt;  ‖f(x)‖₂ =  5.613648e-04  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =  4.914400e-03  δ =  7.907623e-02  ρ =  7.392103e-01
  iter    6  =&gt;  ‖f(x)‖₂ =  6.682932e-06  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =  9.781638e-04  δ =  7.907623e-02  ρ =  9.880952e-01</code></pre><p>Notice that all relevant information is collected in a single object:</p><article class="docstring"><header><a class="docstring-binding" id="NonlinearSystems.NonlinearSystem" href="#NonlinearSystems.NonlinearSystem"><code>NonlinearSystems.NonlinearSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonlinearSystem(::Type{P}, fdf::OnceDifferentiable, x, fx, dx, solver; kwargs...)</code></pre><p>Construct a <code>NonlinearSystem</code> for holding all information used for solving a nonlinear system of equations with problem type <code>P</code>. Users are not expected to use this method directly but should instead call <code>init</code> or <code>solve</code> to generate the problem. Any keyword argument passed to <code>init</code> or <code>solve</code> that is not accepted by a specific solution algorithm is passed to the constructor of <code>NonlinearSystem</code>. For the relevant solution algorithms, see <a href="../solver-options/#NonlinearSystems.Hybrid"><code>Hybrid</code></a>.</p><p><strong>Keywords</strong></p><ul><li><code>lower::Union{AbstractVector, Nothing}=nothing</code>: element-wise lower bounds for solution candidates.</li><li><code>upper::Union{AbstractVector, Nothing}=nothing</code>: element-wise upper bounds for solution candidates.</li><li><code>maxiter::Integer=1000</code>: maximum number of iteration allowed before terminating.</li><li><code>ftol::Real=1e-8</code>: absolute tolerance for the infinity norm of residuals <code>fx</code>.</li><li><code>gtol::Real=1e-10</code>: absolute tolerance for the infinity norm of gradient vector; only relevant for solving least squares.</li><li><code>xtol::Real=0.0</code>: absolute tolerance for the infinity norm of a step <code>dx</code>.</li><li><code>xtolr::Real=0.0</code>: relative tolerance for the infinity norm of a step <code>dx</code> as a proportion of <code>x</code>.</li><li><code>showtrace::Union{Bool,Integer}=false</code>: print summary information for each trial made by the solver; with <code>showtrace=true</code>, information is printed once every 20 iterations; an interger value specifies the gap for printing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/junyuan-chen/NonlinearSystems.jl/blob/74e442f62b0e20d8b221a9656af23742a2df29bb/src/interface.jl#L55-L81">source</a></section></article><p>Instead of calling <code>solve</code> or <code>solve!</code>, which simply iterates <code>NonlinearSystem</code> in a loop, we may manually iterate the solver steps as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = init(Hybrid{LeastSquares}, f!, x0);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s.solver</code><code class="nohighlight hljs ansi" style="display:block;">HybridSolver{Float64, DenseCholeskySolver{Float64, Int8, Matrix{Float64}, Vector{Float64}, Nothing}, Vector{Float64}}:
  iter    1  =&gt;  ‖f(x)‖₂ =  1.687505e+00  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =           NaN  δ =  1.612854e+01  ρ =           NaN</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iterate(s)</code><code class="nohighlight hljs ansi" style="display:block;">(2×2 NonlinearSystem{LeastSquares}(Hybrid, 0.3755760088573572, inprogress), (2, NonlinearSystems.normal, NonlinearSystems.inprogress))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s.solver</code><code class="nohighlight hljs ansi" style="display:block;">HybridSolver{Float64, DenseCholeskySolver{Float64, Int8, Matrix{Float64}, Vector{Float64}, Nothing}, Vector{Float64}}:
  iter    2  =&gt;  ‖f(x)‖₂ =  3.755760e-01  ‖∇f(x)‖₂ =           NaN  ‖Ddx‖₂ =  2.350344e+00  δ =  2.350344e+00  ρ =  7.774372e-01</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../solver-options/">Solver Options »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 1 October 2024 05:23">Tuesday 1 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
